#!/bin/bash

# Local Resolution Control Center (LRCC)
# Batch processor for blocres and blocfilt of cryoSPARC job output.
# (c) Andreas U Mueller - 2021
# --- no warranty, no liability; use at own risk ---
#
#####
#
# Version history:
#
# v1.1 - 20220524
#  - minor code corrections
#
# v1.0 - 20210701
#  - initial release
#
#

version="Local Resolution Control Center (LRCC) - v1.1"

export LC_ALL=C # fix locale setting for consistent sort
SECONDS=0

function run_bloc () {
    local idir_cur="$1"
    local odir_cur="$2"

    # gather input files
    local mapA=($(find "$idir_cur" -name *map_half_A.mrc | sort -r))
    local mapB=($(find "$idir_cur" -name *map_half_B.mrc | sort -r))
    local umap=($(find "$idir_cur" -name *map.mrc | sort -r))
    local smap=($(find "$idir_cur" -name *map_sharp.mrc | sort -r))
    local rmask=($(find "$idir_cur" -name *mask_refine.mrc | sort -r))
    
    # build i/o variables
    local mapA_path=${mapA[0]}
    local mapB_path=${mapB[0]}
    local umap_path=${umap[0]}
    local orimap_path=${smap[0]}
    
    # choose mask file
    if [ -z "$nomask" ]; then
        if [ -z "$mask" ]; then
            ! [ -f "$rmask" ] && echo "Error: $rmask_path does not exist!"
            local rmask_path="-Mask ${rmask[0]}"
        else
            ! [ -f "$mask" ] && echo "Error: $rmask_path does not exist!"
            local rmask_path="-Mask $mask"
        fi
    else
        local rmask_path=""
    fi
    
    #check file existence
    ! [ -f "$mapA_path" ] && echo "Error: $mapA_path does not exist!"
    ! [ -f "$mapB_path" ] && echo "Error: $mapB_path does not exist!"
    ! [ -f "$orimap_path" ] && echo "Error: $orimap_path does not exist!"
    
    local locres_base=$(basename "$orimap_path")
    #local locfil_map=$(basename "$orimap_path")
    
    mkdir -p "$odir_cur"
    local locres_map_path="${odir_cur}/${locres_base::-10}_blocres.mrc"
    local locfil_map_path="${odir_cur}/${locres_base::-4}_blocfilt.mrc"
    local locres_log="${odir_cur}/${locres_base::-10}_blocres.log"
    local locfil_log="${odir_cur}/${locres_base::-4}_blocfilt.log"

    # inform user
    printf '%b\n' "Processing blocres for $idir_cur
    blocres -verbose 1 -box $bxsz -origin $ori $smpl_cmd $maxres_cmd $rmask_path $blocres_opt $mapA_path $mapB_path $locres_map_path"
    
    local START="$(date +%s)"
    
    "$bin_blocres" -verbose 1 -box $bxsz -origin $ori $smpl_cmd $maxres_cmd $rmask_path $blocres_opt "$mapA_path" "$mapB_path" "$locres_map_path" 2> /dev/null 1> "$locres_log"
    
    local DURATION=$[ $(date +%s) - ${START} ]
    echo "blocres completed in ${DURATION} seconds"

    
    printf '%b\n' "Processing blocfilt for $idir_cur
    blocfilt -verbose 3 -box $bxsz $smpl_cmd -Resolution $locres_map_path $rmask_path $blocfilt_opt $orimap_path $locfil_map_path"
    
    local START="$(date +%s)"
    
    "$bin_blocfilt" -verbose 3 -box $bxsz $smpl_cmd -Resolution "$locres_map_path" $rmask_path $blocfilt_opt "$orimap_path" "$locfil_map_path" 2> /dev/null 1> "$locfil_log"
    
    local DURATION=$[ $(date +%s) - ${START} ]
    echo "blocfilt completed in ${DURATION} seconds"

    # flip output maps?
    if [ $flipmap = "TRUE" ]; then
        # check if chimerax is available
        bin_chimerax="$(which chimerax)"
        if [ -z "$bin_chimerax" ]; then
            echo "Error: Cannot find chimerax binary. Please make sure to have it installed and added to your PATH. Skipping map flipping ..."
        else
            maps2flip=($locres_map_path $locfil_map_path)
            for mapfile in $maps2flip; do
                mapfile_flip="$odir_cur/$(basename -s .mrc $mapfile)_flip.mrc"
                chimerax --nogui --cmd "open $mapfile; volume flip #1; save $mapfile_flip models #2; exit"
            done
        fi
    fi
}

# default values
bxsz=20
target="."
ori="0,0,0"
flipmap="FALSE"
jbs=(0)
blocres_opt=""
blocfilt_opt=""
mask=""
nomask=""
N=1

hlpmsg="$version

Batch process cryoSPARC job output with local resolution and local
filtering using blocres/blocfilt.

(c) Andreas U Mueller - 2021

Usage: lrcc [options] input_folder [output_folder]

Point to one or more directories that each contain the half maps and a
sharpened map.

Map files are recognized by pattern matching
half map A        *map_half_A.mrc
half map B        *map_half_B.mrc
sharpened map     *map_sharp.mrc
mask              *mask_refine.mrc

This is the pattern employed by cryoSPARC, so LRCC can process
map files directly from cryoSPARC job directories.

Positional arguments:
    input_folder
    output_folder
Optional arguments:
    -h                      Print this message.

    -b box_size             Choose kernel size for blocres/blocfilt
                             default: 20
    
    -f                      Flip output maps (uses chimerax).

    -j \"job1 job2 ...\"    Specify cryoSPARC jobs to process. If -j is
                             not used, LRCC will search the input
                             directory for maps and no batch processing
                             will be performed.

    -m mask.mrc             Provide a custom mask for blocres/blocfilt.
                             default: *mask_refine.mrc

    -M                      Turn off masking and compute full box.

    -n processes            Number of processes to parallelize.
                             default: 1

    -o x,y,z                Set origin coordinates.
                             default: 0,0,0 ()

    -s sampling             Set bloc sampling. Generally, use the map
                             pixel size (A/px).

    -r resolution           Set maximum resolution in data (in Angstrom).
                             Generally, twice the pixel size.

    -x \"-arg1 -arg2 ...\"  Pass additional arguments to blocres.

    -y \"-arg1 -arg2 ...\"  Pass additional arguments to blocfilt.
"

# parse arguments
while getopts ":hb:fj:mMn:o:s:r:x:y:" opt; do
  case ${opt} in
    h )
      printf '%b\n' "$hlpmsg"
      exit 0
      ;;
    b )
      bxsz=$OPTARG
      ;;
    f )
      flipmap="TRUE"
      ;;
    j )
      jbs=("$OPTARG")
      ;;
    m )
      mask="$OPTARG"
      ;;
    M )
      nomask="TRUE"
      ;;
    n )
      N=$OPTARG
	  ;;
    o )
      ori="$OPTARG"
      ;;
    s )
      smpl_cmd="-sampling $OPTARG"
      ;;
    r )
      maxres_cmd="-maxresolution $OPTARG"
      ;;
    x )
      blocres_opt="$OPTARG"
      ;;
    y )
      blocfilt_opt="$OPTARG"
      ;;
    \? )
      echo "Invalid option: $OPTARG" 1>&2
      ;;
    : )
      echo "Invalid option: $OPTARG requires an argument" 1>&2
      ;;
  esac
done
shift $((OPTIND -1))

# parse positional arguments
idir="$1"
odir="$2"

if [ -z "$idir" ]; then
    echo "Error: No input directory given."
    printf '%b\n' "$hlpmsg"
    exit 1
fi

[ -z "$odir" ] && odir="."

# blocres/blocfilt available?
bin_blocres="$(which blocres)"
bin_blocfilt="$(which blocfilt)"

if [ -z "$bin_blocres" ] || [ -z "$bin_blocfilt" ]; then
	echo "Error: Cannot find blocres/blocfilt binaries. Please make sure to have them installed and added to your PATH."
	exit 1
fi

### execution

# iterate over jobs and process
for j in $jbs; do
    # are jobs used?
    if [ $j = 0 ]; then
        idir_cur="$idir"
        odir_cur="$odir"
    else
        idir_cur="${idir}/$j"
        odir_cur="${odir}/$j"
    fi

    # skip if job folder doesn't exist
    if ! [ -d "$idir_cur" ]; then
        echo "Warning: $idir_cur does not exist! Skipping ..."
        continue
    fi

    # do it
    ((i=i%N)); ((i++==0)) && wait
    run_bloc "$idir_cur" "$odir_cur" &
done

wait

echo "Completed in $SECONDS seconds."
exit 0

exit 2
