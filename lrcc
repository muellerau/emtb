#!/bin/bash

# Local Resolution Control Center (LRCC)
# Batch processor for blocres and bloc on cryoSPARC job output.
# (c) Andreas U Mueller - 2021
# --- no warranty, no liability; use at own risk ---
#

export LC_ALL=C # fix locale setting for consistent sort
SECONDS=0

function run_bloc () {
    local idir_cur="$1"
    local odir_cur="$2"

    # gather input files
    local mapA=($(find "$idir_cur" -name *map_half_A.mrc | sort -r))
    local mapB=($(find "$idir_cur" -name *map_half_B.mrc | sort -r))
    #umap=($(find "$idir_cur" -name *map.mrc | sort -r))
    local smap=($(find "$idir_cur" -name *map_sharp.mrc | sort -r))
    local rmask=($(find "$idir_cur" -name *mask_refine.mrc | sort -r))
    
    # build i/o variables
    local mapA_path=${mapA[0]}
    local mapB_path=${mapB[0]}
    local orimap_path=${smap[0]}
    
    # choose mask file
    if [ -z "$nomask" ]; then
        if [ -z "$mask" ]; then
            ! [ -f "$rmask" ] && echo "Error: $rmask_path does not exist!"
            local rmask_path="-Mask ${rmask[0]}"
        else
            ! [ -f "$mask" ] && echo "Error: $rmask_path does not exist!"
            local rmask_path="-Mask $mask"
        fi
    else
        local rmask_path=""
    fi

    #check file existence
    ! [ -f "$mapA_path" ] && echo "Error: $mapA_path does not exist!"
    ! [ -f "$mapB_path" ] && echo "Error: $mapB_path does not exist!"
    ! [ -f "$orimap_path" ] && echo "Error: $orimap_path does not exist!"
    
    local locres_base=$(basename "$orimap_path")
    #local locfil_map=$(basename "$orimap_path")
    
    mkdir -p "$odir_cur"
    local locres_map_path="${odir_cur}/${locres_base::-10}_blocres.mrc"
    local locfil_map_path="${odir_cur}/${locres_base::-4}_blocfilt.mrc"
    local locres_log="${odir_cur}/${locres_base::-10}_blocres.log"
    local locfil_log="${odir_cur}/${locres_base::-4}_blocfilt.log"

    # inform user
    printf '%b\n' "Processing blocres for $idir_cur
    blocres -verbose 1 -box $bxsz -origin $ori $smpl_cmd $maxres_cmd $rmask_path $blocres_opt $mapA_path $mapB_path $locres_map_path"
    
    local START="$(date +%s)"
    
    blocres -verbose 1 -box $bxsz -origin $ori $smpl_cmd $maxres_cmd $rmask_path $blocres_opt "$mapA_path" "$mapB_path" "$locres_map_path" 2> /dev/null 1> "$locres_log"
    
    local DURATION=$[ $(date +%s) - ${START} ]
    echo "blocres completed in ${DURATION} seconds"

    
    printf '%b\n' "Processing blocfilt for $idir_cur
    blocfilt -verbose 3 -box $bxsz $smpl_cmd -Resolution $locres_map_path $rmask_path $blocfilt_opt $orimap_path $locfil_map_path"
    
    local START="$(date +%s)"
    
    blocfilt -verbose 3 -box $bxsz $smpl_cmd -Resolution "$locres_map_path" $rmask_path $blocfilt_opt "$orimap_path" "$locfil_map_path" 2> /dev/null 1> "$locfil_log"
    
    local DURATION=$[ $(date +%s) - ${START} ]
    echo "blocfilt completed in ${DURATION} seconds"
}

# default values
bxsz=20
target="."
ori="0,0,0"
flipmap="FALSE"
jbs=(0)
blocres_opt=""
blocfilt_opt=""
mask=""
nomask=""
N=1

hlpmsg="Local Resolution Control Center - LRCC

Batch process cryoSPARC job output with local resolution and local filtering
using blocres/blocfilt.

(c) Andreas U Mueller - 2021

Usage: lrcc [options] input_folder [output_folder]

Point to a directory that contains half maps and sharpened maps.

Map files are recognized by pattern matching
half map A        *map_half_A.mrc
half map B        *map_half_B.mrc
sharpened map     *map_sharp.mrc
mask              *mask_refine.mrc

This is the pattern employed by the cryoSPARC tools, so LRCC can process
map files directly from cryoSPARC job directories.

Required arguments:
    input_folder
Optional arguments:
    -h                      Print this message.

    -b box_size             Choose kernel size for blocres/blocfilt
                             default: 20

    -f                      Flip output maps (uses chimerax).

    -j \"job1 job2 ...\"    Specify cryoSPARC jobs to process. If -j is not used,
                             LRCC will search the input directory for maps.

    -m mask.mrc             Provide a custom mask for blocres/blocfilt.
                             default: *mask_refine.mrc

    -M                      Turn off masking and compute full box.

    -n processes            Number of processes to parallelize.
                             default: 1

    -o x,y,z                Set origin coordinates.
                             default: 0,0,0

    -p pixel_size           Set pixel size (A/px).

    -r resolution           Set maximum resolution in data (in Angstrom).
                             Generally, twice the pixel size.

    -x \"-arg1 -arg2 ...\"  Pass additional arguments to blocres.

    -y \"-arg1 -arg2 ...\"    Pass additional arguments to blocfilt.
"

# parse arguments
while getopts ":hb:fj:mMn:o:p:r:x:y:" opt; do
  case ${opt} in
    h )
      printf '%b\n' "$hlpmsg"
      exit 0
      ;;
    b )
      bxsz=$OPTARG
      ;;
    f )
      flipmap="TRUE" # not implemented yet
      echo "sorry, not implemented yet."
      exit 2
      ;;
    j )
      jbs=("$OPTARG")
      ;;
    m )
      mask="$OPTARG"
      ;;
    M )
      nomask="TRUE"
      ;;
    n )
      N=$OPTARG
	  ;;
    o )
      ori="$OPTARG"
      ;;
    p )
      smpl_cmd="-sampling $OPTARG"
      ;;
    r )
      maxres_cmd="-maxresolution $OPTARG"
      ;;
    x )
      blocres_opt="$OPTARG"
      ;;
    y )
      blocfilt_opt="$OPTARG"
      ;;
    \? )
      echo "Invalid option: $OPTARG" 1>&2
      ;;
    : )
      echo "Invalid option: $OPTARG requires an argument" 1>&2
      ;;
  esac
done
shift $((OPTIND -1))

# parse positional arguments
idir="$1"
odir="$2"

if [ -z "$idir" ]; then
    echo "Error: No input directory given."
    printf '%b\n' "$hlpmsg"
    exit 1
fi

[ -z "$odir" ] && odir="."

### execution

# iterate over jobs and process
for j in $jbs; do
    # are jobs used?
    if [ j = 0 ]; then
        idir_cur="$idir"
        odir_cur="$odir"
    else
        idir_cur="${idir}/$j"
        odir_cur="${odir}/$j"
    fi

    # skip if job folder doesn't exist
    if ! [ -d "$idir_cur" ]; then
        echo "Warning: $idir_cur does not exist! Skipping ..."
        continue
    fi

    # do it
    ((i=i%N)); ((i++==0)) && wait
    run_bloc "$idir_cur" "$odir_cur" &
done

wait

echo "Completed in $SECONDS seconds."
exit 0

exit 2